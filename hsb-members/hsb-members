#! /bin/bash

# 	Member list generator for Hackerspace Brussels 
#	(c) 2010 Frederic Pasteleurs <frederic@askarel.be>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

ME=$(basename $0)
DB="$0.csv"
CONFIGFILE="$0.conf"

# Build the prompt array (SQL)
# Format of the structure: SQLINPUT[number]="fieldname|[YN]|field description"
SQL_FIELD[1]="firstname|Y|Firstname:"
SQL_FIELD[2]="name|Y|Family name:"
SQL_FIELD[3]="nickname|Y|Nickname:"
SQL_FIELD[4]="phonenumber|Y|Phone number:"
SQL_FIELD[5]="emailaddress|Y|E-mail address:"
SQL_FIELD[6]="why_member|Y|Please explain why you want to be a member (free text):"
# end of mandatory inputs. The rest is optional
SQL_FIELD[7]="birthdate|N|About you: Your birth date (YYYY-MM-DD):"
SQL_FIELD[8]="birthcity|N|           In which city were you born ?"
SQL_FIELD[9]="birthcountry|N|           In which country ?"
SQL_FIELD[10]="nationalregistry|N|           National registry number:"
SQL_FIELD[11]="snailcommune|N|About your home: which commune:"
SQL_FIELD[12]="snailpostcode|N|                 Postal code:"
SQL_FIELD[13]="snailstreet|N|           Street name:"
SQL_FIELD[14]="snailnumber|N|           House/building number:"
SQL_FIELD[15]="snailbox|N|           Mailbox number (leave empty if N/A):"

# Build the prompt array (CSV)
M_INPUT[1]="Firstname:"
M_INPUT[2]="Family name:"
M_INPUT[3]="Nickname:"
M_INPUT[4]="Phone number:"
M_INPUT[5]="E-mail address:"


############### <FUNCTIONS> ###############
# Function to call when we bail out
die ()
{
    echo "$ME: $1. Exit"
    if [ "_$2" = "_" ]; then
	exit 1
	else
	exit $2
    fi
}

# run a SQL command, data returned is tab-separated 
# exit code 0: request successful
runsql ()
{
    test -z "$1" && die "Empty SQL request"
    mysql -h"$SQLHOST" -u"$SQLUSER" -p"$SQLPASS" -D"$SQLDB" -s --skip-column-names -e "$1" 2>&1
}

# Generate the 'Communication' field for the virement
# Format: +++DDD/DDDD/DDDSS+++
# DDDDDDDDDD: Any number you like. This is the only parameter needed.
# SS: Above number mod 97. Set to 97 if zero.
# Banks love obsolete^Wproven technologies. :-)
mkcomm ()
{
COMMSTR="$1"
COMMSTR="${COMMSTR:0:10}"		# Trim string length to 10
COMM_MODULO=$(expr $COMMSTR % 97 )	# Get reminder
case $COMM_MODULO in			# Padding and/or correction
    "0") COMM_MODULO="97" ;;
    [1-9]) COMM_MODULO="0$COMM_MODULO" ;;
esac
#echo "$COMMSTR$COMM_MODULO" #Debug
echo "+++${COMMSTR:0:3}/${COMMSTR:3:4}/${COMMSTR:7:3}$COMM_MODULO+++" # Chop into blocks
}

listcurrent ()
{
cat $DB|while read LINE; do
	test -z "$(echo $LINE |cut -d ',' -f 8)" && echo "$LINE"
done
}

listcancelled ()
{
cat $DB|while read LINE; do
	test -n "$(echo $LINE |cut -d ',' -f 8)" && echo "$LINE"
done
}

editmember ()
{
echo "$ME: Not implemented: Use a text editor or a spreadsheet program with some common sense. :-)"
}

deletemember ()
{
# Keep backup files around
DBNEW="$DB"
DB=$DB.bak
test -f $DB.bak && rm $DB.bak
test -f $DB && mv $DB $DB.bak
mv $DBNEW $DB
listcancelled > $DBNEW
listcurrent | grep -iv "$1" >> "$DBNEW"
CANCELLINE="$(listcurrent|grep -i "$1" )$(date +%F)"
echo "$CANCELLINE" >> "$DBNEW"
echo "$CANCELLINE: Membership cancelled"
DB=$DBNEW
}

# Pick an active member and do something with him
# Parameter 1: member to work on
# Parameter 2: Function to execute on member
pickactive ()
{
test $# = 2 || die "pickactive() need two parameters"
case $(listcurrent|grep -i $1 |wc -l) in
    0)
    die "$1 not found in active records from file $DB"
    ;;
    1)
    $2 $1
    ;;
    *)
    listcurrent|grep -i $1
    die "$(listcurrent|grep -i $1 |wc -l) results: refine your query"
    ;;
esac
}

############### </FUNCTIONS> ###############

############### <SANITY CHECKS> ###############
# Create member file if it do not exist
if [ ! -f $DB ]; then
    touch $DB || die "Cannot create members file"
fi

# Load config file and check sanity
test -f "$CONFIGFILE" || die "No config file found ($CONFIGFILE)"
. $CONFIGFILE
test -n "$BANKACCOUNT" || die "$CONFIGFILE: BANKACCOUNT variable is empty"
test -n "$BANKNAME" || die "$CONFIGFILE: BANKNAME variable is empty"
test -n "$MAILFROM" || die "$CONFIGFILE: MAILFROM variable (sender e-mail address) is empty"
test -n "$MONTHLYFEE" || die "$CONFIGFILE: MONTHLYFEE variable is empty"
test -n "$SQLUSER" || die "$CONFIGFILE: SQLUSER variable is empty"
test -n "$SQLPASS" || die "$CONFIGFILE: SQLPASS variable is empty"
test -n "$SQLDB" || die "Database to use not specified"
# By delault we talk in euros
test -n "$CURRENCY" || CURRENCY="EUR"
# A year is (usually) 12 months. This is an override if needed
test -n "$YEARLYFEE" || YEARLYFEE=$((12*$MONTHLYFEE))
# In case the bank account number has spaces
BANKACCOUNT=$(echo $BANKACCOUNT|tr -d ' ')
# If empty, use localhost
test -n "$SQLHOST" || SQLHOST="127.0.0.1"
############### </SANITY CHECKS> ###############

#SQLRESULT=$(runsql "show tables;")
#echo $?
#echo "\"$SQLRESULT\""

# Run script
case $1 in
    list-current)
    echo "# date_entered, virement_string, firstname, name, nickname, phonenumber, email"
    listcurrent
    ;;
    add)
# We don't need cryptographically secure hashing here.
# What we need is uniqueness, and the size of the .csv is helping us here.
# With only 10^10 possibilities (a bit more than 2^33), true randomness 
# is just a source of collisions.
    DATALINE="$(date +%F),$(mkcomm $(cat $DB|wc -l)$(cat $DB|wc -c)$RANDOM$RANDOM$RANDOM)"
    for i in $(seq 1 ${#M_INPUT[@]}); do
	echo -n "[$i/${#M_INPUT[@]}] ${M_INPUT[$i]} "
	read
	DATALINE="$DATALINE,$REPLY"
    done
    echo "$DATALINE," >> $DB
    echo "Added to db file: $DATALINE,"
    echo "Hello $(echo $DATALINE|cut -d ',' -f 3),

This e-mail is the confirmation that you are registered as an official
member of Hackerspace Brussels VZW/ASBL.

Since we have to spend money for the facilities, internet and electricity,
we need to ask you some every month. Not much, but it's enough to keep us 
afloat. You can ask your bank to make an automatic transfer to the following
bank account: ${BANKACCOUNT:0:4} ${BANKACCOUNT:4:4} ${BANKACCOUNT:8:4} ${BANKACCOUNT:12:4} ${BANKACCOUNT:16:4} ${BANKACCOUNT:20:4}
Monthly amount: $MONTHLYFEE $CURRENCY
Communication: $(echo $DATALINE|cut -d ',' -f 2)

You *MUST* use the communication string above: it allow us to automate the
day by day follow up of the financial aspect of the association.

-- 
Hackerspace Brussels

This mail is sent automagically from a broken half-assed bash script. You
can see the gory details here: https://github.com/askarel/hsb-members
"| mail -s "HSBXL - Welcome aboard" $(echo $DATALINE|cut -d ',' -f 7) && echo "mail sent to $(echo $DATALINE|cut -d ',' -f 7)"
    ;;
    remove)
    test -z "$2" && die "You must specify member name or e-mail address"
    pickactive $2 deletemember
    ;;
    list-cancelled)
    echo "# date_entered, virement_string, firstname, name, nickname, phonenumber, email, date_cancelled"
    listcancelled
    ;;
    count-current)
    echo "There are $(listcurrent|wc -l) active members in database $DB."
    ;;
    modify)
    test -z "$2" && die "You must specify member name or e-mail address"
    pickactive $2 editmember
    ;;
    dry)
    echo -n "$ME: dry run:  "
#    mkcomm "$(cat $DB|wc -l)$(cat $DB|wc -c)$RANDOM$RANDOM$RANDOM"
    mkcomm "$2"
    #pickactive $2 $3
    ;;
    *)
    echo "Usage: $ME [list-current|add|remove|list-cancelled|count-current|modify|dry]"
    exit 1
    ;;
esac

